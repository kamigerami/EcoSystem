---
- name: Have kubectl already been copied?
  stat: path=/usr/local/bin/kubectl
  register: kubectl_exist

- name: Create Directories
  file:
    dest: "{{ item_directory }}"
    state: directory
  with_items: "{{ directories }}"
  loop_control:
    loop_var: item_directory

- name: Verify if Kubernetes already has downloaded
  local_action: stat path={{ kubernetes_download_dir }}/{{kubernetes_release_server_filename}}.tar.gz
  register: kubernetes_release_exist
  become: no

- name: place make-ca-cert.sh file on host
  copy: src=make-ca-cert.sh dest={{ kubernetes_download_dir }} mode=a+x
  when: inventory_hostname in groups['master']

- name: run make-ca-cert command
  command: "./make-ca-cert.sh {{ id.master_ip }} IP:{{ id.master_ip }},IP:{{ kubelet_cluster_dns_ip }}%.*.1,DNS:kubernetes.default,DNS:kubernetes.default.svc,DNS:kubernetes.default.svc.{{ kubelet_cluster_domain }}"
  args: 
    chdir: "{{ kubernetes_download_dir}}"
  when: inventory_hostname in groups['master']
#
#- name: Download easy rsa 
#  get_url: url={{ kubernetes_cert_url }} dest={{ kubernetes_download_dir }}/easy-rsa.tar.gz
#  when: inventory_hostname in groups['master']
#
#- name: Unarchive easy rsa
#  unarchive: copy=no src={{ kubernetes_download_dir }}/easy-rsa.tar.gz dest={{ kubernetes_download_dir }}
#  when: inventory_hostname in groups['master']
#
#- name: run easyrsa init
#  command: ./easyrsa init-pki > /dev/null 2>&1
#  args:
#    chdir: "{{kubernetes_download_dir}}/easy-rsa-master/easyrsa3" 
#    creates: "{{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/easyrsa" 
#  when: inventory_hostname in groups['master']
#
#- name: run easyrsa batch
#  command: ./easyrsa --batch "--req-cn={{ hostvars[inventory_hostname]['ansible_eth1']['ipv4']['address'] }}@`date +%s`" build-ca nopass > /dev/null 2&1
#  args:
#    chdir: "{{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3"
#  when: inventory_hostname in groups['master']
#
#- name: run easyrsa subject-alt-names 
#  command:  ./easyrsa --subject-alt-name="{{inventory_hostname}}" build-server-full kubernetes-master nopass > /dev/null 2>&1
#  when: inventory_hostname in groups['master']
#
#- name: copy server.cert to certdir
#  copy: src={{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/pki/issued/kubernetes-master.crt dest={{ kubernetes_pki_dir }}/server.cert mode=0660
#  when: inventory_hostname in groups['master']
#
#- name: copy server.key to certdir
#  copy: src={{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/pki/issued/kubernetes-master.key dest={{ kubernetes_pki_dir }}/server.key mode=0660
#  when: inventory_hostname in groups['master']
#
#- name: run easyrsa build full client
#  command:  ./easyrsa build-client-full kubecfg nopass > /dev/null 2>&1
#  when: inventory_hostname in groups['master']
#
#- name: copy ca.crt to certdir
#  copy: src={{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/pki/ca.crt dest={{ kubernetes_pki_dir }}/ca.crt
#  when: inventory_hostname in groups['master']
#
#- name: copy kubecfg.crt to certdir
#  copy: src={{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/pki/issued/kubecfg.crt dest={{ kubernetes_pki_dir }}/kubecfg.crt
#  when: inventory_hostname in groups['master']
#
#- name: copy kubecfg.key to certdir
#  copy: src={{ kubernetes_download_dir }}/easy-rsa-master/easyrsa3/pki/issued/kubecfg.key dest={{ kubernetes_pki_dir }}/kubecfg.key
#  when: inventory_hostname in groups['master']
#
- name: Download kubernetes
  local_action: get_url url={{ kubernetes_release_url_base }}/{{ kubernetes_release_server_filename }}.tar.gz dest={{ kubernetes_download_dir }}/{{kubernetes_release_server_filename }}.tar.gz
  become: no
  register: download_kubernetes_release
  ignore_errors: True

- name: "Verify if Kubernetes already has synchronized to {{ inventory_hostname }}"
  stat: path={{ kubernetes_download_dir }}/{{kubernetes_release_server_filename}}.tar.gz
  register: kubernetes_release_synchronized

- name: Synchronize
  copy: 
    src: "{{ kubernetes_download_dir }}/{{ kubernetes_release_server_filename }}.tar.gz" 
    dest: "{{ kubernetes_download_dir }}/{{ kubernetes_release_server_filename }}.tar.gz" 
  register: kubernetes_release_copied
  when: (kubernetes_release_synchronized.stat.exists == False)
  become: no

- name: Unarchive kubernetes release
  unarchive: copy=no src={{ kubernetes_download_dir }}/{{ kubernetes_release_server_filename }}.tar.gz dest={{ kubernetes_download_dir }}/ creates={{ kubernetes_download_dir }}/kubernetes/server/bin/kubectl
  register: kubernetes_unarchived

- name: copy kubernetes_release_binary to /bin
  copy: src={{kubernetes_download_dir}}/kubernetes/server/bin/{{ kubernetes_release_binary }} dest=/bin/{{ kubernetes_release_binary }} remote_src=yes mode='a+x'
  when: (kubectl_exist.stat.exists == False or kubernetes_unarchived)
  with_items: "{{ kubernetes_binaries }}"
  loop_control:
    loop_var: kubernetes_release_binary

- name: Update file permissions for binary
  file: path=/bin/{{ files }} state=touch mode="a+x"
  with_items: "{{ kubernetes_binaries }}"
  loop_control:
    loop_var: files

- name: Update kubeadm.conf with new CIDR for pods
  lineinfile:
    backup: True
    backrefs: True
    dest: /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
    regexp: '(Environment=.KUBELET_EXTRA_ARGS=.*)"'
    insertafter: "KUBELET_EXTRA_ARGS="
    line: '\1 --pod-cidr={{ calico_ip_range }} --node-ip={{ hostvars[inventory_hostname]["ansible_eth1"]["ipv4"]["address"] }}"'

- name: restart and enable services
  command: /bin/true
  notify:
    - restart systemd
    - enable kubelet
